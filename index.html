<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MyBodhi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; max-width: 720px; margin: 20px auto; padding: 0 12px; }
    #chat { display: flex; flex-direction: column; gap: 8px; margin: 12px 0; }
    .u { align-self: flex-end; background: #e8f0ff; padding: 8px 12px; border-radius: 12px; }
    .b { align-self: flex-start; background: #eee; padding: 8px 12px; border-radius: 12px; }
    .quote { font-style: italic; opacity: .85; margin-top: 6px; }
    .row { display:flex; gap:8px; align-items: center; }
    select, input { padding: 8px; }
    #tree { font-size: 28px; margin-left: auto; }
    .card { border:1px solid #ddd; padding:10px; border-radius:10px; background:#fafafa; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

  <!-- Login Section -->
  <div id="login-section">
    <h2>Login</h2>
    <input type="email" id="login-email" placeholder="Enter your email" />
    <button id="login-btn">Send Magic Link</button>
    <p style="font-size:12px;opacity:.7;margin-top:8px">
      Tip: add your site URL(s) to Supabase Auth &raquo; Redirect URLs (localhost + Netlify URL).
    </p>
  </div>

  <!-- App Section (hidden until logged in) -->
  <div id="app-section" style="display:none;">
    <h1>MyBodhi</h1>

    <!-- Voice controls -->
    <div class="row" style="margin:8px 0;">
      <label>
        <input type="checkbox" id="voice-enabled" />
        Voice
      </label>
      <button id="mic-btn" title="Hold to speak" style="padding:8px;">üé§ Hold</button>
      <select id="voice-select" title="TTS voice"></select>
    </div>

    <!-- Mode + tree -->
    <div class="row" style="margin:8px 0;">
      <label>Mode:
        <select id="mode">
          <option value="chat" selected>Discussion</option>
          <option value="med_breath">Meditation: Breath</option>
          <option value="med_body">Meditation: Body Scan</option>
          <option value="lesson">Lesson</option>
        </select>
      </label>
      <div id="tree">üå±</div>
    </div>

    <!-- Tradition -->
    <label>Tradition:
      <select id="trad">
        <option value="buddhism">Buddhism (Bodhi)</option>
        <option value="zen">Zen (Bonsai)</option>
      </select>
    </label>

    <!-- Chat thread -->
    <div id="chat"></div>

    <!-- Input row -->
    <div class="row">
      <input id="msg" placeholder="Ask for guidance..." style="flex:1" />
      <button id="send">Send</button>
    </div>

    <p id="xp"></p>
  </div>

  <script>
    // ========== CONFIG ==========
    // Supabase (replace with your project URL + anon key)
    const SUPABASE_URL = "https://qqlyzqvszfyvrmyetekr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFxbHl6cXZzemZ5dnJteWV0ZWtyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMTAyMjQsImV4cCI6MjA3MDU4NjIyNH0.pXeijvS9Cny_Ba9LfJtCQYNXbyv5g6meKNhATKIZOFc";
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Backend base URL (flip this to your Render URL on deploy)
    const API_BASE_URL = 'http://127.0.0.1:8000'; // e.g., 'https://your-backend.onrender.com'

    let currentUserId = null;

    // ========== AUTH (MAGIC LINK) ==========
    document.getElementById('login-btn').addEventListener('click', async () => {
      const email = document.getElementById('login-email').value.trim();
      if (!email) return alert("Please enter your email.");
      const { error } = await supabaseClient.auth.signInWithOtp({ email });
      if (error) alert("Error sending magic link: " + error.message);
      else alert("Magic link sent! Check your email.");
    });

    async function showAppIfSession() {
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (session) {
        currentUserId = session.user.id;
        document.getElementById('login-section').style.display = 'none';
        document.getElementById('app-section').style.display = 'block';
        refreshXP();
      }
    }

    supabaseClient.auth.onAuthStateChange((_event, session) => {
      if (session) {
        currentUserId = session.user.id;
        document.getElementById('login-section').style.display = 'none';
        document.getElementById('app-section').style.display = 'block';
        refreshXP();
      }
    });

    // ========== APP LOGIC ==========
    const chat = document.getElementById('chat');
    const msg = document.getElementById('msg');
    const send = document.getElementById('send');
    const trad = document.getElementById('trad');
    const xp = document.getElementById('xp');
    const mode = document.getElementById('mode');
    const tree = document.getElementById('tree');

    const history = [];

    function bubbleHTML(html, cls) {
      const d = document.createElement('div');
      d.className = cls;
      d.innerHTML = html;
      chat.appendChild(d);
      chat.scrollTop = chat.scrollHeight;
    }
    function bubble(text, cls) { bubbleHTML(text, cls); }

    async function refreshXP() {
      if (!currentUserId) return;
      const r = await fetch(`${API_BASE_URL}/progress`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user_id: currentUserId })
      });
      const j = await r.json();
      xp.textContent = `XP: ${j.xp ?? 0}  ‚Ä¢  Streak: ${j.streak ?? 0}`;
      tree.textContent = j.state === 'sprout' ? 'üå±' : (j.state === 'branch' ? 'üåø' : 'üå≥');
    }

    async function doChat(t) {
      bubble(t, 'u');
      history.push({ user: t });
      const body = { user_id: currentUserId, tradition: trad.value, text: t, history };
      const res = await fetch(`${API_BASE_URL}/chat`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(body)
      });
      const data = await res.json();
      const ans = data.answer || data.detail || '(error)';
      bubbleHTML(
        ans + (data.quote ? `<div class="quote">‚Äú${data.quote}‚Äù ‚Äî ${data.source||''}</div>` : ''),
        'b'
      );
      history[history.length - 1].assistant = ans;
      await refreshXP();
    }

    async function startMeditation(kind) {
      const res = await fetch(`${API_BASE_URL}/meditation/start`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ user_id: currentUserId, tradition: trad.value, kind })
      });
      const data = await res.json();
      const steps = data.steps || [];
      bubbleHTML(
        `<div class="card">
           <b>Meditation ‚Ä¢ ${kind.replace('_',' ')}</b>
           <ol>${steps.map(s=>`<li>${s}</li>`).join('')}</ol>
           <button id="doneMed">Mark Complete</button>
         </div>`, 'b'
      );
      document.getElementById('doneMed').onclick = completeMeditation;
      await refreshXP();
    }

    async function completeMeditation() {
      await fetch(`${API_BASE_URL}/meditation/complete`, { 
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ user_id: currentUserId })
      });
      bubble('Meditation marked complete. üåü', 'b');
      await refreshXP();
    }

    async function nextLesson() {
      const res = await fetch(`${API_BASE_URL}/lesson/next`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ user_id: currentUserId, tradition: trad.value })
      });
      const data = await res.json();
      if (data.done) {
        bubble('Level 1 complete for this tradition! üéâ', 'b');
        await refreshXP();
        return;
      }
      const L = data.lesson;
      bubbleHTML(
        `<div class="card">
           <b>Lesson:</b> ${L.title}<br/>
           <i>${L.objective}</i><br/>
           ${data.quote ? `<div class="quote">‚Äú${data.quote}‚Äù ‚Äî ${data.source||''}</div>` : ''}
           <div><b>Exercise:</b> ${L.exercise}</div>
           <button id="completeLesson">Mark Lesson Done</button>
         </div>`, 'b'
      );
      document.getElementById('completeLesson').onclick = async () => {
        await fetch(`${API_BASE_URL}/lesson/complete`, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ user_id: currentUserId, tradition: trad.value, lesson_id: L.id })
        });
        bubble('Lesson marked complete. üåü', 'b');
        await refreshXP();
      };
    }

    async function sendMsg() {
      const t = msg.value.trim();
      const m = mode.value;
      if (!t && m === 'chat') return;
      msg.value = '';

      if      (m === 'chat')       return doChat(t);
      else if (m === 'med_breath') return startMeditation('breath');
      else if (m === 'med_body')   return startMeditation('body_scan');
      else if (m === 'lesson')     return nextLesson();
    }

    send.onclick = sendMsg;
    msg.addEventListener('keydown', e => { if (e.key === 'Enter') sendMsg(); });

    // Show app if already logged in (after magic-link redirect)
    showAppIfSession();

    // ========== VOICE: TTS ==========
    const voiceEnabled = document.getElementById('voice-enabled');
    const voiceSelect = document.getElementById('voice-select');
    let availableVoices = [];
    let selectedVoice = null;

    function loadVoices() {
      availableVoices = window.speechSynthesis ? speechSynthesis.getVoices() : [];
      voiceSelect.innerHTML = "";
      availableVoices.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `${v.name} (${v.lang})${v.default ? ' ‚Äî default' : ''}`;
        voiceSelect.appendChild(opt);
      });
      const preferred = availableVoices.findIndex(v => /Siri|Premium|Enhanced|Natural/i.test(v.name));
      voiceSelect.value = preferred >= 0 ? preferred : 0;
      selectedVoice = availableVoices[voiceSelect.value] || null;
    }
    if ('speechSynthesis' in window) {
      speechSynthesis.onvoiceschanged = loadVoices;
      loadVoices();
    }
    voiceSelect.addEventListener('change', () => {
      selectedVoice = availableVoices[voiceSelect.value] || null;
    });

    function speak(text) {
      if (!voiceEnabled.checked || !('speechSynthesis' in window)) return;
      if (!text || !text.trim()) return;
      const utter = new SpeechSynthesisUtterance(text);
      if (selectedVoice) utter.voice = selectedVoice;
      utter.rate = 1.0;
      utter.pitch = 1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    }

    // ========== VOICE: STT (Push-to-talk) ==========
    const micBtn = document.getElementById('mic-btn');
    let recognizer = null;
    let listening = false;

    function sttSupported() {
      return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
    }
    function createRecognizer() {
      const Ctor = window.SpeechRecognition || window.webkitSpeechRecognition;
      const rec = new Ctor();
      rec.continuous = false;
      rec.interimResults = true;
      rec.lang = 'en-US';
      rec.maxAlternatives = 1;
      return rec;
    }

    if (sttSupported()) {
      recognizer = createRecognizer();
      recognizer.onresult = (event) => {
        let finalText = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const chunk = event.results[i][0].transcript;
          if (event.results[i].isFinal) finalText += chunk;
          else msg.value = chunk; // show interim
        }
        if (finalText.trim()) {
          msg.value = finalText.trim();
          sendMsg(); // auto-send for low latency
        }
      };
      recognizer.onerror = () => { listening = false; };
      recognizer.onend = () => { listening = false; };

      const startListening = () => { if (!listening) { try { recognizer.start(); listening = true; } catch {} } };
      const stopListening  = () => { if (listening)   { try { recognizer.stop(); } catch {} } };

      micBtn.addEventListener('mousedown', startListening);
      micBtn.addEventListener('touchstart', startListening);
      micBtn.addEventListener('mouseup', stopListening);
      micBtn.addEventListener('mouseleave', stopListening);
      micBtn.addEventListener('touchend', stopListening);
    } else {
      micBtn.disabled = true;
      micBtn.title = "Speech recognition not supported in this browser";
    }

    // ========== TTS hook into assistant bubbles ==========
    const __bubbleHTML = bubbleHTML;
    bubbleHTML = function(html, cls) {
      __bubbleHTML(html, cls);
      if (cls === 'b') {
        const div = document.createElement('div');
        div.innerHTML = html;
        speak(div.innerText.trim());
      }
    };
  </script>
</body>
</html>