<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MyBodhi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; max-width: 760px; margin: 20px auto; padding: 0 12px; }
    #chat { display: flex; flex-direction: column; gap: 10px; margin: 16px 0; min-height: 160px; }
    .u { align-self: flex-end; background: #e8f0ff; padding: 10px 12px; border-radius: 12px; max-width: 82%; }
    .b { align-self: flex-start; background: #eee; padding: 10px 12px; border-radius: 12px; max-width: 82%; }
    .sys { color:#666; font-size: 14px; text-align:center; }
    .quote { font-style: italic; opacity: .9; margin-top: 6px; }
    .row { display:flex; gap:10px; align-items: center; flex-wrap: wrap; }
    select, input, button { padding: 10px; font-size: 16px; }
    select, input { border: 1px solid #ccc; border-radius: 12px; }
    button { border: 1px solid #bbb; background: #fafafa; border-radius: 14px; cursor: pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #tree { font-size: 28px; margin-left: auto; }
    .card { border:1px solid #ddd; padding:10px; border-radius:10px; background:#fafafa; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

  <!-- Login Section -->
  <div id="login-section">
    <h2>Login</h2>
    <input type="email" id="login-email" placeholder="Enter your email" />
    <button id="login-btn">Send Magic Link</button>
    <p style="font-size:12px;opacity:.7;margin-top:8px">
      Tip: In Supabase ‚Üí Auth ‚Üí URL Configuration, set Site URL to your deployed URL and add it to Redirect URLs.
    </p>
  </div>

  <!-- App Section (hidden until logged in) -->
  <div id="app-section" style="display:none;">
    <h1>MyBodhi</h1>

    <!-- Voice row (checkbox removed) -->
    <div class="row" style="margin:8px 0;">
      <button id="mic-btn" title="Hold to speak">üé§ Hold</button>
      <select id="voice-select" title="TTS voice"></select>
      <div id="tree">üå±</div>
    </div>

    <!-- Mode + Tradition -->
    <div class="row" style="margin:8px 0;">
      <label>Mode:
        <select id="mode">
          <option value="chat" selected>Discussion</option>
          <option value="med_breath">Meditation: Breath</option>
          <option value="med_body">Meditation: Body Scan</option>
          <option value="lesson">Lesson</option>
        </select>
      </label>
      <label>Tradition:
        <select id="trad">
          <option value="buddhism">Buddhism (Bodhi)</option>
          <option value="zen">Zen (Bonsai)</option>
        </select>
      </label>
    </div>

    <!-- Chat thread -->
    <div id="chat"><div class="sys">Welcome. Hold the mic to speak, or type and press Send.</div></div>

    <!-- Input row -->
    <div class="row">
      <input id="msg" placeholder="Ask for guidance..." style="flex:1" />
      <button id="send">Send</button>
    </div>

    <p id="xp"></p>
  </div>

  <script>
    // ======= APP_URL / API_BASE (canonical app URL + backend URL) =======
    const APP_URL = window.location.origin;
    const isLocalPage = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    const LOCAL_API = 'http://127.0.0.1:8000';
    const PROD_API  = 'https://mybodhi-backend.onrender.com';
    const API_BASE  = isLocalPage ? LOCAL_API : PROD_API; // single source of truth
    window.APP_CONFIG = { APP_URL, API_BASE };

    // (auth redirect handler moved below, after Supabase client is initialized)

    // ======= CONFIG: Supabase =======
    const SUPABASE_URL = "https://qqlyzqvszfyvrmyetekr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFxbHl6cXZzemZ5dnJteWV0ZWtyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMTAyMjQsImV4cCI6MjA3MDU4NjIyNH0.pXeijvS9Cny_Ba9LfJtCQYNXbyv5g6meKNhATKIZOFc";
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // ======= Redirect / confirmation handler (Supabase code flow + hash tokens + optional GoTrue) =======
    async function handleAuthRedirect() {
      const url = new URL(window.location.href);
      const q = url.searchParams;
      const h = new URLSearchParams(window.location.hash.replace(/^#/, ''));

      // --- Supabase v2 PKCE / magic link: ?code=... (&type=signup|recovery|invite|magiclink)
      const code = q.get('code');
      const supaType = q.get('type');
      if (code) {
        try {
          const { data, error } = await supabaseClient.auth.exchangeCodeForSession({ code });
          if (error) console.error('exchangeCodeForSession error:', error);
          else console.log('Supabase session established via code', supaType || '');
        } catch (e) {
          console.error('exchangeCodeForSession threw:', e);
        }
        history.replaceState({}, '', window.location.pathname);
        return;
      }

      // --- Supabase hash tokens style: #access_token=...&refresh_token=...
      const accessToken = h.get('access_token');
      if (accessToken) {
        // supabase-js usually processes this automatically; just clean hash
        try {
          localStorage.setItem('sb-access-token', accessToken);
          const rt = h.get('refresh_token');
          if (rt) localStorage.setItem('sb-refresh-token', rt);
        } catch {}
        history.replaceState({}, '', window.location.pathname);
        return;
      }

      // --- Optional: Netlify/GoTrue confirm (if ever used)
      const confirmToken = q.get('confirmation_token');
      const confirmType  = q.get('type');
      if (confirmToken) {
        fetch(`${window.APP_CONFIG.API_BASE}/auth/confirm?token=${encodeURIComponent(confirmToken)}&type=${encodeURIComponent(confirmType||'')}`, {
          credentials: 'include'
        }).catch(err => console.error('Confirm error', err))
          .finally(() => history.replaceState({}, '', window.location.pathname));
      }
    }

    // Run once on load before checking session
    handleAuthRedirect();

    // Use the same API_BASE everywhere
    const API_BASE_URL = API_BASE;

    let currentUserId = null;
    let booted = false; // prevents double afterLogin()

    // ======= AUTH (Magic Link) =======
    document.getElementById('login-btn').addEventListener('click', async () => {
      const email = document.getElementById('login-email').value.trim();
      if (!email) return alert("Please enter your email.");
      const redirectTo = `${window.APP_CONFIG.APP_URL}${window.location.pathname}`; // canonical
      const { error } = await supabaseClient.auth.signInWithOtp({
        email,
        options: { emailRedirectTo: redirectTo }
      });
      if (error) alert("Error sending magic link: " + error.message);
      else alert("Magic link sent! Check your email.");
    });

    async function showAppIfSession() {
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (session) afterLogin(session);
    }
    supabaseClient.auth.onAuthStateChange((_event, session) => {
      if (session) afterLogin(session);
    });

    function afterLogin(session) {
      if (booted) return;  // <= stop duplicate /progress calls
      booted = true;

      currentUserId = session.user.id;
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('app-section').style.display = 'block';
      if (window.location.hash.includes('access_token=')) {
        history.replaceState(null, '', window.location.pathname);
      }
      refreshXP();
    }

    // ======= APP refs =======
    const chat = document.getElementById('chat');
    const msg = document.getElementById('msg');
    const send = document.getElementById('send');
    const trad = document.getElementById('trad');
    const xp = document.getElementById('xp');
    const mode = document.getElementById('mode');
    const tree = document.getElementById('tree');

    const historyArr = []; // {user, assistant}

    function bubbleHTML(html, cls) {
      const d = document.createElement('div');
      d.className = cls;
      d.innerHTML = html;
      chat.appendChild(d);
      chat.scrollTop = chat.scrollHeight;
    }
    function bubble(text, cls) { bubbleHTML(text, cls); }

    function showFetchError(url, err, resText) {
      const httpsMixed = (location.protocol === 'https:' && API_BASE_URL.startsWith('http:'));
      let hint = httpsMixed
        ? " Your page is HTTPS but the API is HTTP. Use an HTTPS API URL (or run both locally)."
        : "";
      bubble(`‚ö†Ô∏è Failed to fetch from ${url}. ${err?.message || err}. ${resText || ''}${hint}`, 'b');
      console.error('Fetch error', url, err, resText);
    }

    async function fetchJSON(url, bodyObj) {
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify(bodyObj)
        });
        if (!res.ok) {
          const txt = await res.text().catch(()=> '');
          throw new Error(`HTTP ${res.status} ‚Äî ${txt}`);
        }
        return await res.json();
      } catch (e) {
        showFetchError(url, e);
        throw e;
      }
    }

    function renderTree(state) {
      if (state === 'sprout') tree.textContent = 'üå±';
      else if (state === 'branch') tree.textContent = 'üåø';
      else tree.textContent = 'üå≥'; // blossom or any future state
    }

    async function refreshXP() {
      if (!currentUserId) return;
      try {
        const j = await fetchJSON(`${API_BASE_URL}/progress`, { user_id: currentUserId });
        xp.textContent = `XP: ${j.xp ?? 0}  ‚Ä¢  Streak: ${j.streak ?? 0}`;
        renderTree(j.state);
      } catch(_) {}
    }

    async function doChat(t) {
      bubble(t, 'u');
      historyArr.push({ user: t });
      try {
        const data = await fetchJSON(`${API_BASE_URL}/chat`, {
          user_id: currentUserId,
          session_id: currentUserId,     // <= helps Zen ‚ÄúExplain‚Äù path
          tradition: trad.value,
          text: t,
          history: historyArr
        });
        const ans = data.answer || data.detail || '(no content)';
        bubbleHTML(
          ans + (data.quote ? `<div class="quote">‚Äú${data.quote}‚Äù ‚Äî ${data.source||''}</div>` : ''),
          'b'
        );
        historyArr[historyArr.length - 1].assistant = ans;
        await refreshXP();
      } catch(_) {}
    }

    async function startMeditation(kind) {
      try {
        const data = await fetchJSON(`${API_BASE_URL}/meditation/start`, {
          user_id: currentUserId, tradition: trad.value, kind
        });
        const steps = data.steps || [];
        bubbleHTML(
          `<div class="card">
             <b>Meditation ‚Ä¢ ${kind.replace('_',' ')}</b>
             <ol>${steps.map(s=>`<li>${s}</li>`).join('')}</ol>
             <button id="doneMed">Mark Complete</button>
           </div>`, 'b'
        );
        document.getElementById('doneMed').onclick = completeMeditation;
        await refreshXP();
      } catch(_) {}
    }

    async function completeMeditation() {
      try {
        await fetchJSON(`${API_BASE_URL}/meditation/complete`, { user_id: currentUserId });
        bubble('Meditation marked complete. üåü', 'b');
        await refreshXP();
      } catch(_) {}
    }

    async function nextLesson() {
      try {
        const data = await fetchJSON(`${API_BASE_URL}/lesson/next`, {
          user_id: currentUserId, tradition: trad.value
        });
        if (data.done) {
          bubble('Level 1 complete for this tradition! üéâ', 'b');
          await refreshXP();
          return;
        }
        const L = data.lesson || {};
        bubbleHTML(
          `<div class="card">
             <b>Lesson:</b> ${L.title || ''}<br/>
             <i>${L.objective || ''}</i><br/>
             ${data.quote ? `<div class="quote">‚Äú${data.quote}‚Äù ‚Äî ${data.source||''}</div>` : ''}
             <div><b>Exercise:</b> ${L.exercise || ''}</div>
             <button id="completeLesson">Mark Lesson Done</button>
           </div>`, 'b'
        );
        const lessonId = L.id;
        document.getElementById('completeLesson').onclick = async () => {
          try {
            await fetchJSON(`${API_BASE_URL}/lesson/complete`, {
              user_id: currentUserId, tradition: trad.value, lesson_id: lessonId
            });
            bubble('Lesson marked complete. üåü', 'b');
            await refreshXP();
          } catch(_) {}
        };
      } catch(_) {}
    }

    async function sendMsg() {
      const t = msg.value.trim();
      const m = mode.value;
      if (!t && m === 'chat') return;
      msg.value = '';
      if      (m === 'chat')       return doChat(t);
      else if (m === 'med_breath') return startMeditation('breath');
      else if (m === 'med_body')   return startMeditation('body_scan');
      else if (m === 'lesson')     return nextLesson();
    }

    send.onclick = sendMsg;
    msg.addEventListener('keydown', e => { if (e.key === 'Enter') sendMsg(); });

    // ======= TTS (no checkbox; always speak) =======
    const voiceSelect = document.getElementById('voice-select');
    let availableVoices = [], selectedVoice = null;

    function loadVoices() {
      availableVoices = window.speechSynthesis ? speechSynthesis.getVoices() : [];
      voiceSelect.innerHTML = "";
      availableVoices.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `${v.name} (${v.lang})${v.default ? ' ‚Äî default' : ''}`;
        voiceSelect.appendChild(opt);
      });
      const preferred = availableVoices.findIndex(v => /Siri|Premium|Enhanced|Natural/i.test(v.name));
      voiceSelect.value = preferred >= 0 ? preferred : 0;
      selectedVoice = availableVoices[voiceSelect.value] || null;
    }
    if ('speechSynthesis' in window) {
      speechSynthesis.onvoiceschanged = loadVoices;
      loadVoices();
    }
    voiceSelect.addEventListener('change', () => {
      selectedVoice = availableVoices[voiceSelect.value] || null;
    });

    function speak(text) {
      if (!('speechSynthesis' in window)) return;
      if (!text || !text.trim()) return;
      const utter = new SpeechSynthesisUtterance(text);
      if (selectedVoice) utter.voice = selectedVoice;
      utter.rate = 1.0; utter.pitch = 1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    }

    // hook TTS to assistant bubbles
    const __bubbleHTML = bubbleHTML;
    bubbleHTML = function(html, cls) {
      __bubbleHTML(html, cls);
      if (cls === 'b') {
        const tmp = document.createElement('div'); tmp.innerHTML = html;
        speak(tmp.innerText.trim());
      }
    };

    // ======= STT (hold-to-talk) =======
    const micBtn = document.getElementById('mic-btn');
    let recognizer = null, listening = false;
    // guard so late onresult can't rewrite the input after we've sent
    let micSending = false;

    function sttSupported() {
      return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
    }
    function createRecognizer() {
      const Ctor = window.SpeechRecognition || window.webkitSpeechRecognition;
      const rec = new Ctor();
      rec.continuous = false;
      rec.interimResults = true;
      rec.lang = 'en-US';
      rec.maxAlternatives = 1;
      return rec;
    }

    if (sttSupported()) {
      recognizer = createRecognizer();

      recognizer.onresult = (event) => {
        if (micSending) return; // ignore late results while sending
        let finalText = '';
        let interim = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const chunk = event.results[i][0].transcript;
          if (event.results[i].isFinal) finalText += chunk;
          else interim += chunk;
        }
        msg.value = (finalText || interim).trim();
      };

      recognizer.onend = () => {
        if (micSending) msg.value = '';   // make sure the box is clear
        listening = false;
        micBtn.textContent = 'üé§ Hold';
      };

      const startListening = () => {
        if (!listening) {
          try {
            micSending = false;     // new session
            msg.value = '';         // clear any stale text
            recognizer.start();
            listening = true;
            micBtn.textContent = 'üéôÔ∏è Listening‚Ä¶';
          } catch {}
        }
      };

      const stopListening = () => {
        if (listening) { try { recognizer.stop(); } catch {} }
        const t = msg.value.trim();
        micBtn.textContent = 'üé§ Hold';
        if (t) {
          micSending = true;
          Promise.resolve(sendMsg()).finally(() => {
            micSending = false;
            msg.value = '';         // re-clear after any trailing results
          });
        } else {
          msg.value = '';
        }
        listening = false;
      };

      micBtn.addEventListener('mousedown', startListening);
      micBtn.addEventListener('touchstart', startListening, { passive:false });
      micBtn.addEventListener('mouseup', stopListening);
      micBtn.addEventListener('mouseleave', () => { if (listening) stopListening(); });
      micBtn.addEventListener('touchend', stopListening);
    } else {
      micBtn.disabled = true;
      micBtn.title = "Speech recognition not supported in this browser";
    }


    // Boot: show app if already logged in
    showAppIfSession();
  </script>
</body>
</html>
