<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MyBodhi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#fff; --ink:#111; --muted:#666; --bubble:#eef2f7; --ububble:#e8f0ff; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 760px; margin: 20px auto; padding: 0 12px; color: var(--ink); }
    h1 { font-size: 44px; margin: 0 0 16px; letter-spacing: .5px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    select, input, button { padding: 10px 12px; font-size: 16px; }
    select, input { border: 1px solid #ccc; border-radius: 12px; }
    button { border: 1px solid #bbb; background: #fafafa; border-radius: 14px; cursor: pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #chat { display: flex; flex-direction: column; gap: 10px; margin: 16px 0 18px; min-height: 160px; }
    .u { align-self: flex-end; background: var(--ububble); padding: 10px 12px; border-radius: 14px 14px 2px 14px; max-width: 82%; }
    .b { align-self: flex-start; background: var(--bubble); padding: 10px 12px; border-radius: 14px 14px 14px 2px; max-width: 82%; }
    .sys { color: var(--muted); font-size: 14px; text-align:center; }
    .quote { font-style: italic; opacity: .9; margin-top: 6px; }
    #composer { display:flex; gap:8px; align-items:center; }
    #msg { flex:1; }
    #micBtn { display:flex; gap:8px; align-items:center; }
    .seed { font-size: 28px; margin-left:auto; }
  </style>
</head>
<body>
  <h1>MyBodhi</h1>

  <div class="row">
    <button id="micBtn" title="Hold to speak">
      ðŸŽ¤ Hold
    </button>
    <select id="voiceSel" aria-label="Voice">
      <option>Alex (en-US) â€” default</option>
    </select>
    <span class="seed">ðŸŒ±</span>
  </div>

  <div class="row">
    <label>Mode:</label>
    <select id="modeSel">
      <option value="chat">Chat</option>
      <option value="lesson" selected>Lesson</option>
      <option value="meditation">Meditation</option>
    </select>

    <label>Tradition:</label>
    <select id="tradSel">
      <option value="buddhism">Buddhism (Bodhi)</option>
      <option value="stoicism">Stoicism</option>
      <option value="taoism">Taoism</option>
    </select>
  </div>

  <div id="chat" aria-live="polite">
    <div class="sys">Welcome. Type or hold the mic, then release to send.</div>
  </div>

  <div id="composer">
    <input id="msg" placeholder="Ask for guidance..." autocomplete="off" />
    <button id="sendBtn">Send</button>
  </div>

  <script>
    // ---------- CONFIG ----------
    const API_BASE = "http://127.0.0.1:8000";

    // Endpoints used. Adjust here if your backend differs.
    const ROUTES = {
      chat:        `${API_BASE}/chat`,
      lessonNext:  `${API_BASE}/lesson/next`,
      meditationNext: `${API_BASE}/meditation/next`
    };

    // ---------- UI ELEMENTS ----------
    const chat      = document.getElementById('chat');
    const msgInput  = document.getElementById('msg');
    const sendBtn   = document.getElementById('sendBtn');
    const modeSel   = document.getElementById('modeSel');
    const tradSel   = document.getElementById('tradSel');
    const micBtn    = document.getElementById('micBtn');

    // ---------- CHAT HELPERS ----------
    function addBubble(text, who='b') {
      const div = document.createElement('div');
      div.className = who;
      div.textContent = text;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
      return div;
    }

    function addError(err) {
      const m = typeof err === 'string' ? err : (err?.message || 'Unknown error');
      addBubble('âš ï¸ ' + m, 'b');
      console.error(err);
    }

    function setBusy(state) {
      sendBtn.disabled = state;
      micBtn.disabled  = state;
      msgInput.disabled = state;
    }

    // Build request payloads consistently.
    function buildPayload(mode, text) {
      const tradition = tradSel.value;
      // Normalize empty to null
      const clean = (s) => (s && s.trim().length ? s.trim() : null);

      if (mode === 'lesson') {
        // If your backend needs only tradition, it will ignore text.
        return { tradition, text: clean(text) };
      }
      if (mode === 'meditation') {
        return { tradition, text: clean(text) };
      }
      // chat
      return { text: clean(text), tradition };
    }

    async function sendMsg(source = 'typed') {
      const mode = modeSel.value;
      const text = msgInput.value;

      if (!text?.trim() && (mode === 'chat')) {
        msgInput.focus();
        return;
      }

      // Show user's message (even if empty for lesson/meditation prompt)
      if (text?.trim()) addBubble(text.trim(), 'u');

      setBusy(true);

      try {
        let url;
        if (mode === 'lesson') url = ROUTES.lessonNext;
        else if (mode === 'meditation') url = ROUTES.meditationNext;
        else url = ROUTES.chat;

        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify(buildPayload(mode, text))
        });

        if (!res.ok) {
          const t = await res.text().catch(()=> '');
          throw new Error(`HTTP ${res.status} from ${url}${t ? ` â€” ${t}` : ''}`);
        }

        // Accept a few possible shapes from the backend.
        const data = await res.json().catch(() => ({}));

        let botText =
          data.reply ?? data.text ?? data.message ?? data.content ??
          (data.title && data.body ? `${data.title}\n\n${data.body}` : null);

        // If the lesson endpoint returns a lesson object
        if (!botText && data.lesson) {
          const L = data.lesson;
          botText = [
            L.title ? `â€¢ ${L.title}` : null,
            L.summary ?? null,
            L.text ?? null
          ].filter(Boolean).join('\n\n');
        }

        if (!botText) botText = 'â€¦ (no content returned)';

        addBubble(botText, 'b');
      } catch (err) {
        addError(err);
      } finally {
        // Only clear AFTER weâ€™ve sent / rendered
        msgInput.value = '';
        setBusy(false);
        msgInput.focus();
      }
    }

    sendBtn.addEventListener('click', sendMsg);
    msgInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMsg();
      }
    });

    // ---------- HOLDâ€‘TOâ€‘TALK (Web Speech API) ----------
    // We use webkitSpeechRecognition for widest support in Chrome.
    let rec = null;
    let holding = false;

    function ensureRecognizer() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return null;
      const r = new SR();
      r.lang = 'en-US';
      r.continuous = false;
      r.interimResults = true;
      r.maxAlternatives = 1;
      return r;
    }

    function startHold() {
      if (holding) return;
      holding = true;

      rec = ensureRecognizer();
      if (!rec) {
        addError('Speech recognition not supported in this browser. Type instead.');
        holding = false;
        return;
      }

      micBtn.textContent = 'ðŸŽ™ï¸ Listeningâ€¦ (hold)';
      msgInput.placeholder = 'Listeningâ€¦';

      let interim = '';
      let finalText = '';

      rec.onresult = (evt) => {
        interim = '';
        for (let i = evt.resultIndex; i < evt.results.length; i++) {
          const tx = evt.results[i][0].transcript;
          if (evt.results[i].isFinal) finalText += tx;
          else interim += tx;
        }
        // Show live transcript; DO NOT clear it automatically
        msgInput.value = (finalText + ' ' + interim).trim();
      };

      rec.onerror = (e) => {
        console.warn('rec error', e);
        addError('Mic error: ' + (e.error || 'unknown'));
      };

      rec.onend = () => {
        // Do nothing here; we handle sending on stopHold().
      };

      try { rec.start(); } catch(e) {
        // start() can throw if called twice fast
        console.warn(e);
      }
    }

    async function stopHold() {
      if (!holding) return;
      holding = false;

      micBtn.textContent = 'ðŸŽ¤ Hold';
      msgInput.placeholder = 'Ask for guidanceâ€¦';

      try { rec && rec.stop(); } catch(e) { /* ignore */ }

      // Auto-send whatever is in the box (if any)
      const txt = msgInput.value?.trim();
      if (txt?.length) {
        await sendMsg('voice');
      }
    }

    // Mouse + touch for hold-to-talk
    micBtn.addEventListener('mousedown', startHold);
    micBtn.addEventListener('mouseup', stopHold);
    micBtn.addEventListener('mouseleave', () => { if (holding) stopHold(); });

    micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); }, { passive:false });
    micBtn.addEventListener('touchend',   (e) => { e.preventDefault(); stopHold(); },   { passive:false });

    // ---------- BOOT ----------
    // Optional: prime the server by hitting /lesson/next when in Lesson with empty input on first Send.
    // Already handled: clicking Send in Lesson/Meditation with empty box sends a prompt to those endpoints.
  </script>
</body>
</html>
